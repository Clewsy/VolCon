   1               		.file	"USART.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	initUSART
  12               	initUSART:
  13               	.LFB0:
  14               		.file 1 "USART.c"
   1:USART.c       **** //Functions used for serial communications via USART
   2:USART.c       **** 
   3:USART.c       **** #include <USART.h>
   4:USART.c       **** 
   5:USART.c       **** //Initialise the USART peripheral
   6:USART.c       **** void initUSART(void)
   7:USART.c       **** {
  15               		.loc 1 7 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
   8:USART.c       **** 	//Utilising USART0
   9:USART.c       **** 	UBRR1H = UBRRH_VALUE;	//USART Baud Rate Register 1 High -Value defined in util/setbaud.h
  21               		.loc 1 9 0
  22 0000 1092 CD00 		sts 205,__zero_reg__
  10:USART.c       **** 	UBRR1L = UBRRL_VALUE;	//USART Baud Rate Register 1 Low  -Value defined in util/setbaud.h
  23               		.loc 1 10 0
  24 0004 8FEC      		ldi r24,lo8(-49)
  25 0006 8093 CC00 		sts 204,r24
  11:USART.c       **** 
  12:USART.c       **** 	#if USE_2X						//Double-Speed detemined in util/setbaud.h.  Needed is defined BAUD not achieavabl
  13:USART.c       **** 		UCSR1A |= (1 << U2X1);		//UCSR1A = USART 1 Control and Status Register A
  14:USART.c       **** 	#else							//U2X1 = Double USART 1 Transmission Speed Enable
  15:USART.c       **** 		UCSR1A &= ~(1 << U2X1);
  26               		.loc 1 15 0
  27 000a E8EC      		ldi r30,lo8(-56)
  28 000c F0E0      		ldi r31,0
  29 000e 8081      		ld r24,Z
  30 0010 8D7F      		andi r24,lo8(-3)
  31 0012 8083      		st Z,r24
  16:USART.c       **** 	#endif
  17:USART.c       **** 	
  18:USART.c       **** 	UCSR1B = (1 << RXCIE1) | (1 << TXEN1) | (1 << RXEN1);		//UCSR1B = USART 1 Control and Status Regis
  32               		.loc 1 18 0
  33 0014 88E9      		ldi r24,lo8(-104)
  34 0016 8093 C900 		sts 201,r24
  19:USART.c       **** 																//RXCIE1 = USART 1 RX Complete Interrupt Enable
  20:USART.c       **** 																//TXEN1 = Transmit Enable USART1
  21:USART.c       **** 																//RXEN1 = Receive Enable USART1
  22:USART.c       **** 	UCSR1C = (1 << UCSZ11) | (1 << UCSZ10);					//UCSR1C = USART 1 Control and Status Register C
  35               		.loc 1 22 0
  36 001a 86E0      		ldi r24,lo8(6)
  37 001c 8093 CA00 		sts 202,r24
  38 0020 0895      		ret
  39               		.cfi_endproc
  40               	.LFE0:
  42               	.global	receiveByte
  44               	receiveByte:
  45               	.LFB1:
  23:USART.c       **** 																//UCSZ12:0 = Usart Character Size, Set to 0b011 for 8-bit.
  24:USART.c       **** 																//(USBS = Usart Stop Bit Select, Stays at 0b0 for 1 stop bit)
  25:USART.c       **** }
  26:USART.c       **** 
  27:USART.c       **** //Sets a variable to whatever was received by the USART
  28:USART.c       **** uint8_t receiveByte(void)
  29:USART.c       **** {
  46               		.loc 1 29 0
  47               		.cfi_startproc
  48               	/* prologue: function */
  49               	/* frame size = 0 */
  50               	/* stack size = 0 */
  51               	.L__stack_usage = 0
  52               	.L4:
  30:USART.c       **** 
  31:USART.c       **** 	while (!(UCSR1A & (1 << RXC1))) {}		//Wait until the USART 0 receive complete flag is set 
  53               		.loc 1 31 0 discriminator 1
  54 0022 8091 C800 		lds r24,200
  55 0026 87FF      		sbrs r24,7
  56 0028 00C0      		rjmp .L4
  32:USART.c       **** 	return UDR1;							//Returns received data.  UDR0 = USART 0 Data Register
  57               		.loc 1 32 0
  58 002a 8091 CE00 		lds r24,206
  33:USART.c       **** }
  59               		.loc 1 33 0
  60 002e 0895      		ret
  61               		.cfi_endproc
  62               	.LFE1:
  64               	.global	transmitByte
  66               	transmitByte:
  67               	.LFB2:
  34:USART.c       **** 
  35:USART.c       **** 
  36:USART.c       **** //Transmits a byte from the USART
  37:USART.c       **** void transmitByte(uint8_t data)
  38:USART.c       **** {
  68               		.loc 1 38 0
  69               		.cfi_startproc
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 0 */
  73               	.L__stack_usage = 0
  74               	.LVL0:
  75               	.L8:
  39:USART.c       **** 	while (!(UCSR1A & (1 << UDRE1))) {}	//Wait until the USART 0 data register is empty (ready to tran
  76               		.loc 1 39 0 discriminator 1
  77 0030 9091 C800 		lds r25,200
  78 0034 95FF      		sbrs r25,5
  79 0036 00C0      		rjmp .L8
  40:USART.c       **** 	UDR1 = data;							//UDR0 = USART 0 Data Register
  80               		.loc 1 40 0
  81 0038 8093 CE00 		sts 206,r24
  82 003c 0895      		ret
  83               		.cfi_endproc
  84               	.LFE2:
  86               	.global	printString
  88               	printString:
  89               	.LFB3:
  41:USART.c       **** }
  42:USART.c       **** 
  43:USART.c       **** //Transmits a string of characters.
  44:USART.c       **** void printString(const char string[])
  45:USART.c       **** {			
  90               		.loc 1 45 0
  91               		.cfi_startproc
  92               	.LVL1:
  93 003e 1F93      		push r17
  94               	.LCFI0:
  95               		.cfi_def_cfa_offset 3
  96               		.cfi_offset 17, -2
  97 0040 CF93      		push r28
  98               	.LCFI1:
  99               		.cfi_def_cfa_offset 4
 100               		.cfi_offset 28, -3
 101 0042 DF93      		push r29
 102               	.LCFI2:
 103               		.cfi_def_cfa_offset 5
 104               		.cfi_offset 29, -4
 105               	/* prologue: function */
 106               	/* frame size = 0 */
 107               	/* stack size = 3 */
 108               	.L__stack_usage = 3
 109 0044 EC01      		movw r28,r24
 110               	.LVL2:
  46:USART.c       **** 	uint8_t i = 0;								//Counter to increment for every character in the string.
 111               		.loc 1 46 0
 112 0046 10E0      		ldi r17,0
 113               	.LVL3:
 114               	.L10:
  47:USART.c       **** 	while ((string[i]) != '\0')				//Until null character (end of string).
 115               		.loc 1 47 0 discriminator 1
 116 0048 FE01      		movw r30,r28
 117 004a E10F      		add r30,r17
 118 004c F11D      		adc r31,__zero_reg__
 119 004e 8081      		ld r24,Z
 120 0050 8823      		tst r24
 121 0052 01F0      		breq .L12
  48:USART.c       **** 	{
  49:USART.c       **** 		transmitByte(string[i]);				//UCSR0A = USART 0 Control and Status Register A
 122               		.loc 1 49 0
 123 0054 0E94 0000 		call transmitByte
 124               	.LVL4:
  50:USART.c       **** 		i++;									//UDRE0 = USART 0 Data Register Empty Flag
 125               		.loc 1 50 0
 126 0058 1F5F      		subi r17,lo8(-(1))
 127               	.LVL5:
 128 005a 00C0      		rjmp .L10
 129               	.L12:
 130               	/* epilogue start */
  51:USART.c       **** 	}
  52:USART.c       **** }
 131               		.loc 1 52 0
 132 005c DF91      		pop r29
 133 005e CF91      		pop r28
 134               	.LVL6:
 135 0060 1F91      		pop r17
 136               	.LVL7:
 137 0062 0895      		ret
 138               		.cfi_endproc
 139               	.LFE3:
 141               	.global	printByte
 143               	printByte:
 144               	.LFB4:
  53:USART.c       **** 
  54:USART.c       **** //Takes an integer and transmits the characters
  55:USART.c       **** void printByte(uint8_t byte)
  56:USART.c       **** {
 145               		.loc 1 56 0
 146               		.cfi_startproc
 147               	.LVL8:
 148 0064 CF93      		push r28
 149               	.LCFI3:
 150               		.cfi_def_cfa_offset 3
 151               		.cfi_offset 28, -2
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	/* stack size = 1 */
 155               	.L__stack_usage = 1
 156 0066 C82F      		mov r28,r24
 157               	.LVL9:
 158               	.L15:
  57:USART.c       **** 	//(modified to only print last 2 digits (tens & ones)).
  58:USART.c       **** 	//while (!(UCSR1A & (1 << UDRE1))) {}	//Wait until the USART 0 data register is empty (ready to tr
  59:USART.c       **** 	//transmitByte('0'+ (byte/100));		//Hundreds
  60:USART.c       **** 	while (!(UCSR1A & (1 << UDRE1))) {}	//Wait until the USART 0 data register is empty (ready to tran
 159               		.loc 1 60 0 discriminator 1
 160 0068 8091 C800 		lds r24,200
 161 006c 85FF      		sbrs r24,5
 162 006e 00C0      		rjmp .L15
  61:USART.c       **** 	transmitByte('0'+ ((byte/10) % 10));	//Tens
 163               		.loc 1 61 0
 164 0070 2AE0      		ldi r18,lo8(10)
 165 0072 8C2F      		mov r24,r28
 166 0074 622F      		mov r22,r18
 167 0076 0E94 0000 		call __udivmodqi4
 168 007a 0E94 0000 		call __udivmodqi4
 169 007e 80E3      		ldi r24,lo8(48)
 170 0080 890F      		add r24,r25
 171 0082 0E94 0000 		call transmitByte
 172               	.LVL10:
 173               	.L17:
  62:USART.c       **** 	while (!(UCSR1A & (1 << UDRE1))) {}	//Wait until the USART 0 data register is empty (ready to tran
 174               		.loc 1 62 0 discriminator 1
 175 0086 8091 C800 		lds r24,200
 176 008a 85FF      		sbrs r24,5
 177 008c 00C0      		rjmp .L17
  63:USART.c       **** 	transmitByte('0'+ (byte % 10));		//Ones
 178               		.loc 1 63 0
 179 008e 8C2F      		mov r24,r28
 180 0090 6AE0      		ldi r22,lo8(10)
 181 0092 0E94 0000 		call __udivmodqi4
 182 0096 80E3      		ldi r24,lo8(48)
 183 0098 890F      		add r24,r25
 184               	/* epilogue start */
  64:USART.c       **** }
 185               		.loc 1 64 0
 186 009a CF91      		pop r28
 187               	.LVL11:
  63:USART.c       **** 	transmitByte('0'+ (byte % 10));		//Ones
 188               		.loc 1 63 0
 189 009c 0C94 0000 		jmp transmitByte
 190               	.LVL12:
 191               		.cfi_endproc
 192               	.LFE4:
 194               	.Letext0:
 195               		.file 2 "g:\\projects\\winavr-20100110\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 USART.c
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:2      *ABS*:0000003e __SP_H__
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:3      *ABS*:0000003d __SP_L__
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:4      *ABS*:0000003f __SREG__
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:5      *ABS*:00000000 __tmp_reg__
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:6      *ABS*:00000001 __zero_reg__
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:12     .text:00000000 initUSART
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:44     .text:00000022 receiveByte
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:66     .text:00000030 transmitByte
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:88     .text:0000003e printString
C:\Users\Jadonis\AppData\Local\Temp\cckWb3iU.s:143    .text:00000064 printByte

UNDEFINED SYMBOLS
__udivmodqi4
